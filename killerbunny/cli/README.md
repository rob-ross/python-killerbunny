# Using JSON Path REPL

## Basic commands:

* help or ? : display available commends
* help `<command>` : display help on a command. E.g., `help parse`
* value : show currently loaded json root value. This defaults to the "Bookstore" JSON sample from RFC 9535 pg 11
* value -l : display JSON value on multiple lines, i.e., "pretty print" it
* `<json path query string>` : evaluate the query string against the currently loaded root value
  * Example: 
```json lines
(jpath repl) > value -l
json value: {
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      {
        "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      {
        "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 399,
      "foo": null
    }
  }
}

(jpath repl) > $..book[*]

lexer:    DOLLAR, DOUBLE_DOT, ID:book, LBRACKET, STAR, RBRACKET, EOF
ASTNode:  jsonpath_query
    ast:  ${DS{bs[ns:book]/bs}/DS, CS{bs[*]/bs}/CS}/$

eval result: type: VNodeList
len: 4. (Type 'result' for list of result nodes)
(jpath repl) > result

VNodeList(len=4 VNodes)
_______________________
0.    $['store']['book'][0]
{'category': 'reference', 'author': 'Nigel Rees', 'title': 'Sayings of the Century', 'price': 8.95}
1.    $['store']['book'][1]
{'category': 'fiction', 'author': 'Evelyn Waugh', 'title': 'Sword of Honour', 'price': 12.99}
2.    $['store']['book'][2]
{'category': 'fiction', 'author': 'Herman Melville', 'title': 'Moby Dick', 'isbn': '0-553-21311-3', 'price': 8.99}
3.    $['store']['book'][3]
{'category': 'fiction', 'author': 'J. R. R. Tolkien', 'title': 'The Lord of the Rings', 'isbn': '0-395-19395-8', 'price': 22.99}

```
* lex : just run the lexer on the query string. e.g.:
```text
(jpath repl) > lex $..book[*]

lexer:    DOLLAR, DOUBLE_DOT, ID:book, LBRACKET, STAR, RBRACKET, EOF
```

* parse : show the AST generated by the parser. (Also displays lexer output)
E.g.:
```text
(jpath repl) > parse $..book[*]

lexer:    DOLLAR, DOUBLE_DOT, ID:book, LBRACKET, STAR, RBRACKET, EOF
ASTNode:  jsonpath_query
    ast:  ${DS{bs[ns:book]/bs}/DS, CS{bs[*]/bs}/CS}/$

```
* evaluate `<json path query string>` : equivalent to just 
* `<json path query string>` 

E.g., both produce same output:
```text
(jpath repl) > $..book[*]
(jpath repl) > evaluate $..book[*]

```
* load `<file path>` :  load a json value from a .json file on the local filesystem, replacing the previously loaded root value.
E.g.,
```text
(jpath repl) > load ... ./foo/bar/baz.json
```
* ls, cd, pwd, dir : simple versions of typical *nix terminal commands
* ast : display AST(s) for most recent query command
* errors : display error(s) of most recent query command
* 
### subparse
try to parse the query string as a specific grammar production rule.
E.g.:
```text
Bad query:
(jpath repl) > 1:1
lexer:    SLICE:1:1, EOF
**** parser Error: Invalid Syntax: start: Expected '$', got SLICE at position 1
^1:1^

(jpath repl) > subparse selector 1:1
lexer:    SLICE:1:1, EOF
Parsing succeeded. 0 subparse errors reported.
ASTNode:  selector
    ast:  slice(1:1:)

Bad query:
(jpath repl) > @.price < 10
lexer:    AT, DOT, ID:price, LT, INT:10, EOF
**** parser Error: Invalid Syntax: start: Expected '$', got @ at position 1
^@^.price < 10

(jpath repl) > subparse comparison_expr @.price < 10
lexer:    AT, DOT, ID:price, LT, INT:10, EOF
Parsing succeeded. 0 subparse errors reported.
ASTNode:  comparison_expr
    ast:  comp_expr(@{sqs{ns:price}}/@, <, 10)
```
(Above, 'sqs' = 'singular_query_segment, 'ns' = 'name_selector')

You can also omit the speciic grammar production rule and it will attempt to parse the query string with all productions
registered for the subparse command. Parsings that succeeded are displayed. E.g.:
```text
(jpath repl) > subparse @.price < 10
lexer:    AT, DOT, ID:price, LT, INT:10, EOF
Parsing succeeded. 11 subparse errors reported.
ASTNode:  comparison_expr
    ast:  comp_expr(@{sqs{ns:price}}/@, <, 10)

ASTNode:  basic_expr
    ast:  comp_expr(@{sqs{ns:price}}/@, <, 10)

(jpath repl) > subparse count(@.price)
lexer:    ID:count, LPAREN, AT, DOT, ID:price, RPAREN, EOF
Parsing succeeded. 9 subparse errors reported.
ASTNode:  function_expr
    ast:  count(@ segments<CS{bs[ns:price]/bs}/CS>)->ValueType

ASTNode:  comparable
    ast:  count(@ segments<CS{bs[ns:price]/bs}/CS>)->ValueType

ASTNode:  test_expr
    ast:  count(@ segments<CS{bs[ns:price]/bs}/CS>)->ValueType

ASTNode:  basic_expr
    ast:  count(@ segments<CS{bs[ns:price]/bs}/CS>)->ValueType
```
Use `errors` to see the parsings that failed:
```text
(jpath repl) > errors
Last errors ( 9 ):
------------------
error[0] Invalid Syntax: singular_query: Expected '@' or '$', got ID at position 1
^count^(@.price)
error[1] Invalid Syntax: filter_query: Expected '@' or '$', got ID at position 1
^count^(@.price)
error[2] Invalid Syntax: comparison_expr: Expected '==', '!=', '<=', '>=', '<', '>', got EOF at position 15
count(@.price)^^
error[3] Invalid Syntax: selector: Expected selector, got 'ID' at position 1
^count^(@.price)
error[4] Invalid Syntax: bracketed_selection: Expected '[', found IDENTIFIER: count at position 1
^count^(@.price)
error[5] identifier: No EOF: subparse: Parsing completed before EOF at position 6
count^(@.price)^
error[6] Invalid Syntax: string_literal: Expected string literal, got ID at position 1
^count^(@.price)
error[7] Invalid Syntax: child_segment: Expected [ or . but got IDENTIFIER: count at position 1
^count^(@.price)
error[8] Invalid Syntax: jsonpath_query: Expected '$', found 'ID' at position 1
^count^(@.price)
```

### subeval
Attempts to evalute the partial AST by subparsing the query string against the currently loaded root value. 
TBD

Also TBD, specify "current node" value for productions that use the current node identiier '@'